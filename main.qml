import QtQuick 2.1
import QtQuick.Controls 1.1
import QtQuick.Window 2.0
import Qt.labs.settings 1.0
import Qt.WebSockets 1.0

Window {
    id: frame

    height: 300
    width: 500
    visible: true

    SystemPalette {
        id: systemPalette
        colorGroup: {
            if (Qt.application.state == Qt.ApplicationActive) {
                SystemPalette.Active
            } else {
                SystemPalette.Inactive
            }
        }
    }

    property int margins: 10
    property int labelAlignment: Qt.AlignRight
    property string hostname: 'morgoth'
    property string port: '9090'
    property string kodiUrl: 'ws://' + hostname + ':' + port + '/jsonrpc'
    property string xbmcUrl: 'http://' + hostname + ':8080/jsonrpc'
    property bool connected: false
    property string loglevel: 'notice'

    // These are the loglevels defined in RFC5424, also used by rsyslog.
    // Except for 'none'.
    property var loglevels: {
        'none': -1,
        'error': 3,
        'warning': 4,
        'notice': 5,
        'info': 6,
        'debug': 7
    }

    // Maps which functions should be executed when a notification is received.
    // Notifications from the category 'Internal' were not sent by Kodi, but
    // are generated by this program. The category has these members:
    // Internal.OnConnectionEstablished, Interal.OnConnectionLost
    property var notificationMap: {'notification': ['functions']}

    // Stores data about requests, used to call the correct setterFunction
    // when a response is received.
    property var awaitingResponse: {'id': ['method', 'params', 'setterFunction']}
    // Which entries in awaitingResponse may be overwritten
    property var usableIds: []
    // When no entries can be overwritten, create a new one with id=highestId
    property int highestId: 0

    // Customisable shortcuts
    property string shortcut_left: 'Left'
    property string shortcut_left1: ''
    property string shortcut_right: 'Right'
    property string shortcut_right1: ''
    property string shortcut_up: 'Up'
    property string shortcut_up1: ''
    property string shortcut_down: 'Down'
    property string shortcut_down1: ''
    property string shortcut_back: 'Backspace'
    property string shortcut_back1: ''
    property string shortcut_select: 'Return'
    property string shortcut_select1: 'Enter'
    property string shortcut_context: 'Menu'
    property string shortcut_context1: ''
    property string shortcut_info: 'I'
    property string shortcut_info1: ''
    property string shortcut_home: 'H'
    property string shortcut_home1: ''
    property string shortcut_enterText: 'T'
    property string shortcut_enterText1: ''
    property string shortcut_settings: ''
    property string shortcut_settings1: ''
    property string shortcut_playpause: 'Space'
    property string shortcut_playpause1: ''
    property string shortcut_stop: 'Escape'
    property string shortcut_stop1: ''
    property string shortcut_next: 'N'
    property string shortcut_next1: ''
    property string shortcut_previous: 'P'
    property string shortcut_previous1: ''
    property string shortcut_osd: 'O'
    property string shortcut_osd1: ''
    property string shortcut_playpauseselect: ''
    property string shortcut_playpauseselect1: ''

    // Which audio/subtitles to use when a video is started
    property string defaultAudio: ''
    property string defaultSubtitles: ''

    Settings {
        category: 'Window'
        property alias x: frame.x
        property alias y: frame.y
        property alias width: frame.width
        property alias height: frame.height
    }
    Settings {
        category: 'Other'
        property alias hostname: frame.hostname
        property alias port: frame.port
        property alias loglevel: frame.loglevel
    }
    Settings {
        category: 'Shortcuts'
        property alias left: frame.shortcut_left
        property alias left1: frame.shortcut_left1
        property alias right: frame.shortcut_right
        property alias right1: frame.shortcut_right1
        property alias up: frame.shortcut_up
        property alias up1: frame.shortcut_up1
        property alias down: frame.shortcut_down
        property alias down1: frame.shortcut_down1
        property alias back: frame.shortcut_back
        property alias back1: frame.shortcut_back1
        property alias select: frame.shortcut_select
        property alias select1: frame.shortcut_select1
        property alias context: frame.shortcut_context
        property alias context1: frame.shortcut_context1
        property alias info: frame.shortcut_info
        property alias info1: frame.shortcut_info1
        property alias home: frame.shortcut_home
        property alias home1: frame.shortcut_home1
        property alias enterText: frame.shortcut_enterText
        property alias enterText1: frame.shortcut_enterText1
        property alias settings: frame.shortcut_settings
        property alias settings1: frame.shortcut_settings1
        property alias playpause: frame.shortcut_playpause
        property alias playpause1: frame.shortcut_playpause1
        property alias stop: frame.shortcut_stop
        property alias stop1: frame.shortcut_stop1
        property alias next: frame.shortcut_next
        property alias next1: frame.shortcut_next1
        property alias previous: frame.shortcut_previous
        property alias previous1: frame.shortcut_previous1
        property alias osd: frame.shortcut_osd
        property alias osd1: frame.shortcut_osd1
        property alias playpauseselect: frame.shortcut_playpauseselect
        property alias playpauseselect1: frame.shortcut_playpauseselect1
    }
    Settings {
        category: 'Video'
        property alias defaultAudio: frame.defaultAudio
        property alias defaultSubtitles: frame.defaultSubtitles
    }

    WebSocket {
        id: webSocket
        url: kodiUrl
        active: true

        onStatusChanged: {
            if (status == WebSocket.Connecting) {
                log('debug', 'Connecting â€¦')
            } else if (status == WebSocket.Open) {
                connected = true
            } else if (status == WebSocket.Closing) {
                log('debug', 'About to close connection')
            } else if (status == WebSocket.Closed) {
                connected = false
            } else if (status == WebSocket.Error) {
                log('debug', 'Connection error: ' + errorString)
            }
        }
        onErrorStringChanged: {
            if (errorString != '') {
                log('error', 'Connection Error: ' + errorString)
                //errorString = ''
            }
        }
        onTextMessageReceived: {
            //log('debug', message)
            var jsonObj = eval('(' + message + ')')
            // Handle notifications
            if (jsonObj.id == null) {
                log('debug', jsonObj.method)
                if (dictContainsKey(notificationMap, jsonObj.method)) {
                    var functions = notificationMap[jsonObj.method]
                    for (var i=0; i < functions.length; i++) {
                        functions[i](jsonObj.params)
                    }
                }
            } else {
                if (jsonObj.id < highestId) {
                    var request = awaitingResponse[jsonObj.id]
                    getResponse(request[0], request[1], jsonObj, request[2])
                    awaitingResponse[jsonObj.id] = null
                    usableIds.push(jsonObj.id)
                } else {
                    log('error', 'Response has an unrecognised id.')
                }
            }
        }
    }

    Timer {
        id: reconnectTimer
        interval: 4200
        repeat: true
        triggeredOnStart: false
        running: ! connected
        onTriggered: {
            console.log("Reconnection attempt")
            webSocket.active = false
            webSocket.active = true
        }
    }

    function dictContainsKey(dict, key) {
        return Object.keys(dict).indexOf(key) != -1 && dict[key] != null
    }

    // Add a function to call when a specific notification is received
    function addNotificationFunction(notification, functn) {
        if (dictContainsKey(notificationMap, notification)) {
            notificationMap[notification].push(functn)
        } else {
            notificationMap[notification] = [functn]
        }
    }

    //FIXME: add function.
    // Remove a function from the functions to call when a specific
    // notification is received.
    function removeNotificationFunction(notification, functn) {
    }

    function emulateNotification(notification) {
        if (dictContainsKey(notificationMap, notification)) {
            var functions = notificationMap[notification]
            for (var i=0; i < functions.length; i++) {
                functions[i](null)
            }
        }
    }

    // Deprecated, use sendRequest instead.
    function requestData(method, params, setterMethod) {
        sendRequest(method, params, setterMethod)
    }

    // Send a command to kodi that does not expect an answer.
    // example: sendCommand('"Input.Up"', '{}')
    function sendCommand(methodString, paramsString) {
        sendRequest(methodString, paramsString, null)
    }

    // Send a command to kodi that expects an answer, call setterMethod when
    // the response is received.
    // (Call getResponse which then calls setterMethod)
    function sendRequest(method, params, setterMethod) {
        var id = 0
        if (usableIds.length > 0) {
            id = usableIds.pop()
        } else {
            id = highestId
            highestId += 1
        }
        awaitingResponse[id] = [method, params, setterMethod]
        var text = '{"jsonrpc": "2.0"' + 
            ', "id": ' + id +
            ', "method": ' + method +
            ', "params": ' + params +
            '}'
        webSocket.sendTextMessage(text)
    }

    // When a response is received, check whether it's an error. If not, call
    // the setterMethod (if given).
    function getResponse(method, params, jsonObj, setterMethod) {
        if (jsonObj.error != null) {
            if ( ! expectedError(method, params, jsonObj.error)) {
                logToConsole('error', 
                    'Error processing request:\n' +
                    '\t' + method + '(' + params + ')\n\t' +
                    jsonObj.error.code + ': ' +
                    jsonObj.error.message + '(' +
                    jsonObj.error.data + ')'
                )
                logToBox('error', 'Error sending ' + method)
            }
        // setterMethod is null if no response was expected
        } else if (setterMethod != null) {
            setterMethod(jsonObj)
        }
    }

    function expectedError(method, params, error) {
        // -32100: "Failed to execute method"
        if (error.code == '-32100') {
            // Requesting player properties when there is no player results in
            // an error. If the player changes after the host sent a reply to
            // updatePlayeridBox() and before it receives a player request,
            // these errors can (to my knowledge) not be prevented.
            // FIXME: ignoring them altogether isn't such a good idea though.
            if (method.indexOf('"Player.') == 0 &&
                ( ! (method == '"Player.GetActivePlayers"'))) {
                return true
            }
        }
    }

    function log(level, message) {
        logToConsole(level, message)
        logToBox(level, message)
    }

    function logToConsole(level, message) {
        if (loglevels[level] <= loglevels[loglevel]) {
            console.log(message)
        }
    }

    // Logs to messageBox.
    function logToBox(level, message) {
        if (loglevels[level] <= loglevels[loglevel]) {
            var messageText = message
            if (level == 'error') {
                var messageColor = 'red'
            } else if (level == 'warning') {
                var messageColor = 'yellow'
            } else {
                var messageColor = 'blue'
            }
            messageBox.showMessage(messageText, messageColor)
            messageTimer.restart()
        }
    }

    // Update connectionBox when the connection changes and log it to console
    // with the current time.
    onConnectedChanged: {
        if (connected) {
            logToConsole('debug', 
                    new Date().toLocaleTimeString() +
                    ': Connection established.'
            )
            connectionBox.text = ''
            emulateNotification('Internal.OnConnectionEstablished')
        } else {
            logToConsole('warning',
                    new Date().toLocaleTimeString() +
                    ': Connection lost.'
            )
            connectionBox.text = 'Connection lost.'
            emulateNotification('Internal.OnConnectionLost')
        }
    }

    TabView {
        id: tabView
        anchors.fill: parent
        style: MyTabViewStyle {}

        onCurrentIndexChanged: {
            getTab(currentIndex).forceActiveFocus()
        }

        Rectangle {
            z: 1
            id: connectionBox
            anchors.top: parent.top
            anchors.right: parent.right
            width: 0
            height: 0
            border.width: 1
            border.color: 'black'
            radius: 2
            color: 'red'
            property string text: 'No connection found'
            states: State {
                name: "visible"; when: connectionBox.text != ''
                PropertyChanges {
                    target: connectionText
                    text: connectionBox.text
                }
                PropertyChanges {
                    target: connectionBox
                    width: connectionText.width + 4
                    height: connectionText.height + 4
                }
            }
            transitions: Transition {
                to: "visible"
                reversible: true
                SequentialAnimation {
                    PropertyAnimation {
                        target: connectionBox
                        properties: "width,x,y"
                        duration: 0
                    }
                    PropertyAnimation {
                        target: connectionBox
                        property: "height"
                        duration: 250
                    }
                }
            }

            Label {
                z: 1
                id: connectionText
                anchors.centerIn: parent
                text: ''
            }
        }

        Rectangle {
            z: 1
            id: messageBox
            anchors.top: connectionBox.bottom
            anchors.right: parent.right
            width: 0
            height: 0
            border.width: 1
            border.color: 'black'
            color: 'blue'
            property string text: ''
            property string lastText: ''
            property color lastColor: 'transparent'
            state: "hidden"

            function showMessage(text, col) {
                if (text == '') {
                    messageBox.state = "hidden"
                    messageBox.text = ''
                } else if (messageBox.state == "hidden") {
                    messageBox.text = text
                    messageBox.color = col
                    messageBox.state = "visible"
                } else {
                    messageBox.lastText = messageBox.text
                    messageBox.lastColor = messageBox.color
                    messageBox.state = "textChanged"
                    messageBox.text = text
                    messageBox.color = col
                    messageBox.state = "visible"
                }
            }

            states: [
                State {
                    name: "visible"
                    PropertyChanges {
                        target: messageBox
                        width: messageText.width + 4
                        height: messageText.height + 4
                        color: messageBox.color
                    }
                    PropertyChanges {
                        target: messageText
                        text: messageBox.text
                    }
                }, State {
                    name: "textChanged"
                    PropertyChanges {
                        target: messageBox
                        width: messageText.width + 4
                        height: messageText.height + 4
                        color: messageBox.lastColor
                    }
                    PropertyChanges {
                        target: messageText
                        text: messageBox.lastText
                    }
                }, State { name: "hidden" }
            ]
            transitions: [
                Transition {
                    from: "hidden"
                    reversible: true
                    SequentialAnimation {
                        PropertyAnimation {
                            target: messageBox
                            properties: "width,x,y"
                            duration: 0
                        }
                        PropertyAnimation {
                            target: messageBox
                            properties: "height"
                            duration: 150
                        }
                    }
                }, Transition {
                    from: "textChanged"
                    PropertyAnimation {
                        target: messageBox
                        properties: "width,color"
                        duration: 100
                    }
                }
            ]
            Label {
                id: messageText
                anchors.centerIn: parent
                text: ''
            }
        }

        // Hide the messageBox after <interval> milliseconds.
        Timer {
            id: messageTimer
            interval: 2500
            onTriggered: {
                messageBox.showMessage('', 'blue')
            }
        }


        MainTab {
            id: mainTab
            Component.onCompleted: forceActiveFocus()
        }
        VideoTab {
            id: videoTab
        }
        SettingsTab {
            id: settingsTab
        }
    }
}
